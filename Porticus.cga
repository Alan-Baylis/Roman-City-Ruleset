/**
 * File:    RomanPorticus.cga
 * Created: 15 Feb 2014 10:04:24 GMT
 * Author:  Marie Saldana
 */

version "2013.1"

import col : "Colonnade.cga"
import dom : "Domus.cga" (houseType = "ROMAN SHOPS", baseHeight = 0, redWall_on = "false")		
import rf:   "Roof.cga"	
import tex : "TexturesAssets.cga"	


#-------Scene Settings			

@Group("SceneSettings",0)
attr elevation 	= 0

@Group("SceneSettings",0) @Range(-800,300)
attr YEAR		= 0

@Group("SceneSettings",0) @Range("OFF","ON")
attr Materials_View		= "OFF"
	const materials			= Materials_View == "ON"
	const noMaterials		= Materials_View == "OFF"

@Group("SceneSettings",0)@Range("HIGH","MED","LOW")
attr LOD					= "LOW"
	const highLOD 				= LOD == "HIGH"
	const medLOD				= LOD == "MED"
	const lowLOD				= LOD == "LOW"
	
#--------Materials
	
@Group ("Materials",1) @Range("Under Construction","Brick","Travertine", "Marble", "None", "Varied")
attr Material				= 	case noMaterials && YEAR >= start_date && YEAR <= end_date: "Varied"
								case materials && YEAR >= construction_start && YEAR <=construction_end: "Under Construction"
								case materials && YEAR >= brick_start && YEAR <=brick_end: "Brick"
								case materials && YEAR >= travertine_start && YEAR <=travertine_end: "Travertine"
								case materials && YEAR >= marble_start && YEAR <=marble_end: "Marble"
								else: "None"
								
	const constr				= Material == "Under Construction" 
	const brick					= Material == "Brick"
	const trav					= Material == "Travertine"
	const marble				= Material == "Marble"
	const noModel				= Material == "None"
		

const MaterialColor			= 	case constr: construction_color
								case brick: brick_color
								case trav: travertine_color
								case marble: marble_color							
								else: wall

@Group ("Materials",1) @Range("Green", "Gravel")
attr groundType				= "Gravel"

#-------General

@Group("General",2)@Range("TUSCAN","DORIC","IONIC","CORINTHIAN")
attr order_						= "DORIC"
	const tuscan					= order_ == "TUSCAN"
	const doric						= order_ == "DORIC"
	const ionic						= order_ == "IONIC"
	const corinthian				= order_ == "CORINTHIAN"
	
@Group("General",2)@Range("STOA","PORTICUS","STOA+SHOPS","PORTICUS+SHOPS","SHOPS","PALAESTRA","PROPYLON","COLONNADE STREET", "COLONNADE STREET + SHOPS")
attr building_type 				= "PORTICUS"
	const shops					= building_type == "SHOPS" || building_type == "PORTICUS+SHOPS" || building_type == "STOA+SHOPS" || building_type == "COLONNADE STREET + SHOPS"
	const propylon				= building_type == "PROPYLON"
	
@Group("General",2)@Range("COLONNADE","ARCADE")
attr colonnadeType				= 	"COLONNADE"							
	const columns					= colonnadeType == "COLONNADE"
	const arches					= colonnadeType == "ARCADE"
	
@Group("General",2)@Range("LINEAR", "OFFSET", "SEGMENTED")
attr shapeType					= 	"SEGMENTED"
	const linear 					= shapeType == "LINEAR"
	const offset					= shapeType == "OFFSET"
	const single					= shapeType == "SEGMENTED"

@Group("General",2)
attr stoaDepth 				= 10
	
@Group("General","end type",2)@Range("wall","colonnade","open")	
attr left					= "open"

@Group("General","end type",2)@Range("wall","colonnade","open")	
attr right					= "open"

@Group("General","back type",2)@Range("wall","colonnade","open")	
attr back					= "open"
	
const stoaHeight 			= 	columnHeight+entablatureH
const height				= 	baseHeight+columnHeight+entablatureH
	
							
#-------Base
@Group("Base",3)@Range("continuous", "spaced", "none")
attr stepType 				= "continuous"
	const continuous		= stepType == "continuous"
	const spaced			= stepType == "spaced"
	const noStep			= stepType == "none"
	
@Group("Base",3)
attr steps 					= 5

@Group("Base",3)
attr extra_steps_down		= 0

@Group("Base",3)@Range("true","false")
attr backSteps				= "false"

@Group("Base",3)@Range("true","false")
attr rightSteps				= "false"

@Group("Base",3)@Range("true","false")
attr leftSteps				= "false"

@Group("Base",3)	
attr step_depth 			= .35

@Group("Base",3)	
attr step_height 			= .2

@Group("Base",3)
attr ground_height			= .5

@Group("Base",3)
attr extra_height			= 0

@Group("Base",3)
attr stairW					= case columns: columnSpacing-column_diameter-col.columnOffset*2
							  else: archWidth

const baseHeight 			= steps*step_height+extra_steps_down*step_height

#------Colonnade

@Group("Colonnade",4)
attr column_diameter 			= 	case arches: archColumnDiameter else: 0.6

@Group("Colonnade",4)
attr columnSpacing				= 	case tuscan && columns: 	column_diameter*4
									case doric && columns: 		column_diameter*2.5
									case ionic && columns: 		column_diameter*5.5	
									case corinthian && columns: column_diameter*9
									case tuscan && arches: 		archColumnDiameter*4
									case doric && arches: 		archColumnDiameter*2.5
									case ionic && arches: 		archColumnDiameter*5.5	
									else: 						archColumnDiameter*9
@Group("Colonnade",4)	
attr plinthH 					= 	case arches: archWidth/2 else: 0

@Group("Colonnade","Propylon",4)	
attr centerOpening_propylon		= 	1 #factor of columnSpacing

@Group("Colonnade","Propylon",4)@Range("TETRASTYLE","HEXASTYLE")	
attr propylon_style			= 	"TETRASTYLE"
	const tetrastyle			= 	propylon_style == "TETRASTYLE"
	const hexastyle				= 	propylon_style == "HEXASTYLE"
								
const columnHeight				= 	case tuscan && columns: column_diameter*7+plinthH
									case doric && columns: 	column_diameter*5.5+plinthH
									case ionic && columns: 	column_diameter*9+plinthH
									case corinthian && columns: column_diameter*10+plinthH
									else: archH
const entablatureH				= 	case columns: column_diameter*col.entablatureH
									else: archColumnDiameter*col.entablatureH

#-------Arcade

@Group("Arcade",5) @Range("Front Side", "Both Sides", "Off")
attr showOrders 					= "Front Side"
	const singleSide				= showOrders == "Front Side"
	const bothSides					= showOrders == "Both Sides"
	const ordersOff					= showOrders == "Off"
@Group("Arcade",5) 
attr archWidth					= 	3

const archColumnDiameter 		= 	archWidth/10
const archH						= 	(1.5*archWidth)+plinthH-archWidth/2
const orderW					= 	col.orderW

#-------Segmented Shape Type

@Group("Segment Type",6)@Range("start","middle","last","standalone")
attr segment				= "standalone"
	const start					= segment == "start"
	const middle				= segment == "middle"
	const last					= segment == "last"
	const standalone			= segment == "standalone"

#-------Linear Shape Type

@Group("Linear Type",7)
attr sides				=  4


#-------Shops

@Group("Shops",8)@Range("true","false")
attr noPorticus				= "false"

@Group("Shops",8)
attr shopDepth				= case !shops: 0 else: 4
	
#--------Walls

const wallThickness 		= 1

#--------Roof

@Group("Roof",9)@Range("shed","gable","flat")
attr roofType				= "gable"

@Group("Roof",9)
attr roof_angle 			= case roofType == "gable": 13.8 else: 10

const roofBrickW 			= columnSpacing *0.25
const roofBrickH 			= columnSpacing *0.35
const railingH				= 1

#-------Texture Size

const tile					= columnHeight
const streetTexTile 		= 5

#-------Time Periods

@Group ("Time Period",10) @Order(0) @Range(-800,300)
attr start_date	= 0
@Group ("Time Period",10) @Order(0) @Range(-800,300)
attr end_date	= 0
@Group ("Time Period",10) @Order(1) @Range(-800,300)
attr construction_start	= 0
@Group ("Time Period",10) @Order(2) @Range(-800,300)
attr construction_end	= 0
@Group ("Time Period",10) @Order(3) @Range(-800,300)
attr brick_start		= 0
@Group ("Time Period",10) @Order(4) @Range(-800,300)
attr brick_end			= 0
@Group ("Time Period",10) @Order(5) @Range(-800,300)
attr travertine_start	= 0
@Group ("Time Period",10) @Order(6) @Range(-800,300)
attr travertine_end		= 0
@Group ("Time Period",10) @Order(7) @Range(-800,300)
attr marble_start       = 0
@Group ("Time Period",10) @Order(8) @Range(-800,300)
attr marble_end			= 0

#-------Colors

@Group("Colors",11)
attr base					= case noMaterials || materials && noModel: "#CDC6AD" else: MaterialColor
@Group("Colors",11)@Range( "#EEEEEE", "#F5F5F5","#FFFFFF","#E0E0D1","#AAAAA0")
attr wall					= case noMaterials  || materials && noModel: 20% : "#EEEEEE" 20% : "#F5F5F5" 20% : "#FFFFFF" 20% : "#E0E0D1" else : "#AAAAA0" else: MaterialColor
@Group("Colors",11)
attr wood					= case noMaterials  || materials && noModel: "#40331B" else: MaterialColor
@Group("Colors",11)@Range( "#EEEEEE", "#F5F5F5","#FFFFFF","#E0E0D1","#AAAAA0")
attr column					= case noMaterials  || materials && noModel: 20% : "#EEEEEE" 20% : "#F5F5F5" 20% : "#FFFFFF" 20% : "#E0E0D1" else : "#AAAAA0" else: MaterialColor
@Group("Colors",11)
attr architrave				= case noMaterials  || materials && noModel: "#E8DCC5" else: MaterialColor
@Group("Colors",11)
attr frieze					= case noMaterials  || materials && noModel: "#EBD8B5" else: MaterialColor
@Group("Colors",9)
attr metopes				= case noMaterials  || materials && noModel: "#EBD8B5" else: MaterialColor
@Group("Colors",9)
attr triglyph				= case noMaterials  || materials && noModel: "#B5B59F" else: MaterialColor
@Group("Colors",11)
attr cornice				= case noMaterials  || materials && noModel: "#C9C0AD" else: MaterialColor
@Group("Colors",11)@Range("#A8763D", "#ff6600",  "#9E4F0E", "#B56A00", "#A3650D", "#AB6118")
attr roof					= case noMaterials  || materials && noModel: 15% : "#A8763D" 15% : "#9E4F0E" 15% : "#B56A00" 15% : "#A3650D" else : "#AB6118" else: MaterialColor
@Group ("Colors",11)
attr floor					= case noMaterials  || materials && noModel: "#A68F74" else: MaterialColor
@Group ("Colors",11)
attr ground					= case noMaterials  || materials && noModel: "#ADB38F" else: MaterialColor

const construction_color	= "#F7EB9E" 
const brick_color			= "#705C46" 
const travertine_color		= "#E2E8D1" 
const marble_color			= "#F79E9E"

const blue					= "#0066FF"
const red					= "#FF3300"
const green					= "#33CC33"
const pink					= "#FF6699"
const cyan					= "#00FFFF"
const purple				= "#6600CC"
const orange				= "#FF9900"


///////////
//////START

Shops -->
case noPorticus == "true" && !noModel:
// t(0,elevation,0)Lot.

///*
	t(0,elevation,0)
	extrude(height)
	split(y){baseHeight:color(base)t(0,-extra_steps_down*step_height,0)
					comp(f){top:color(floor)tex.Block("floor",.5)
							|front: Steps
							|left:Wall
							|right:Wall
							|back: Wall}
			|~1:color(wall)split(z){shopDepth:comp(f){front:dom.LowerFacade(rint(rand(-.5,1.5)),"front")
											|left:Wall
											|right:Wall
											|back:Wall}
											//|top:Roof}
									|~1: NIL}
			|entablatureH: comp(f){side:Entablature
									|top:Ceiling [color(floor)tex.Block("floor",.5)]Roof1}
									
			}
case noPorticus == "false" && !noModel:	Lot
//*/
else: // t(0,elevation,0)Lot.
 NIL


Lot -->
//t(0,elevation,0)
//Lot.

///*
case offset && !noModel:
	t(0,elevation,0)
	innerRect
	[offset(-stoaDepth)t(0,ground_height,0) OffsetStoa]
	extrude(ground_height)color (ground) GroundTexture
case single && !noModel:
	alignScopeToAxes(y)
	SegmentStoa(scope.sy)
case linear && !noModel: 	
	t(0,elevation,0)
	LinearStoa
else: NIL
//*/
//////////////////
///////OFFSET STOA

GroundTexture -->
case groundType == "Gravel":
	tex.Block("ground",5)
else: tex.Block("green")

OffsetStoa  --> comp(f) { inside: NIL | border: OffsetStoa2 }

OffsetStoa2 -->
color(base)
extrude(baseHeight)
t(0,-extra_steps_down*step_height,0)
comp(f) {4: Steps 
		|1: extrude(stoaHeight)
			comp(f) {1: color (roof)Roof 
					|4: split(y){col.columnHeight: OffsetColonnade
								|~1:Entablature}
					|2: color(wall) OffsetWall
					|0: [t(0,0,-columnHeight)offset(-column_diameter,inside)color(roof) tex.Block("roof",4,24)] reverseNormals color(floor) tex.Block("floor",.5) }
		|2: Wall}

OffsetColonnade -->
case columns: color(column)col.NoFirstLastOnCorner(columnSpacing)
else: color(wall)col.OffsetArcade
		
OffsetWall -->
case shops: ShopWalls
else: Wall

//////////////////
///////LINEAR STOA

# n = comp.index
# y = comp.total
# sides = number of walls +1
# n == 0 floor
# n == 1 roof
# n == 2 last end colonnade (sides = number of exterior faces +1) 
# n < sides = walls
# n == sides = start end colonnade
# n == sides+1	= first column side
# n == y-1 		= last side
		
LinearStoa -->
color(base)
extrude(baseHeight)
t(0,-extra_steps_down*step_height,0)
comp(f){all: LinearBaseSide(comp.index, comp.total)}

LinearBaseSide(n,y) -->
case n == 1: 				extrude(stoaHeight) comp(f) {all: color(wall)LinearSide(comp.index, comp.total)}
case n <= sides && n>1: 	color(base) tex.Block("wall",tile)
case n > sides && n<y-1 : 	color(base) Steps
case n == y-1:				StepsEnd
else: 						NIL

LinearSide(n,y) -->
case n == 0: reverseNormals color(floor) tex.Block("floor",.5) #Floor
			reverseNormals t(0,0,-columnHeight)offset(-column_diameter,inside)color(roof) tex.Block("roof",4,24) #Ceiling
		//	reverseNormals t(0,0,-entablatureH)color(floor) tex.Block("floor",.5) #Flat Roof
case n == 1: Roof #Roof
case !shops && n>2 && n < sides: Walls #Back Walls
case shops  && n>2 && n < sides: split(y){~1:ShopWalls|entablatureH: Entablature}#Back Walls - Shops
case n == sides && left == "colonnade" && columns:  split(y){~1: s(scope.sx-shopDepth,'1,'1)t(shopDepth,0,0)col.FirstLastFlush(columnSpacing)|entablatureH: Entablature} #start end colonnade (left)
case n == sides && left == "colonnade" && arches:  split(y){~1: s(scope.sx-shopDepth,'1,'1)t(shopDepth,0,0)col.LinearArcade|entablatureH: Entablature} #start end arcade (left)
case n == sides && left == "open": split(y){~1: NIL|entablatureH: Entablature} #start end open(left)
case n == sides && left == "wall": split(y){~1: s(scope.sx-shopDepth,'1,'1)t(shopDepth,0,0) Wall|entablatureH: Entablature} #start end wall (left)
case n == sides+1 && n < y-1 && columns && left != "colonnade": split(y){~1: color(column) col.FirstFlushLastOnBreak(columnSpacing)|entablatureH: Entablature} #ColonnadeMiddle (first inner side)
case n == sides+1 && n < y-1 && columns && left == "colonnade": split(y){~1: color(column) col.NoFirstLastOnBreak(columnSpacing)|entablatureH: Entablature} #ColonnadeMiddle (first inner side)
case n > sides+1 && n < y-1 && columns: split(y){~1: color(column) col.NoFirstLastOnBreak(columnSpacing)|entablatureH: Entablature} #ColonnadeMiddle 
case n == y-1 && columns && right == "colonnade": split(y){~1: color(column) col.NoFirstNoLast(columnSpacing)|entablatureH: Entablature} #ColonnadeMiddle (last inner side)
case n == y-1 && columns && right != "colonnade": split(y){~1: color(column) col.NoFirstLastFlush(columnSpacing)|entablatureH: Entablature} #ColonnadeMiddle (last inner side)
case n > sides && n <= y-1 && arches: split(y){~1: col.LinearArcade|entablatureH: Entablature} #ArcadeMiddle 
case n == 2 && right == "colonnade" && columns: split(y){~1: s(scope.sx-shopDepth,'1,'1)col.FirstLastFlush(columnSpacing)|entablatureH: Entablature} #last end colonnade (right)(columns)
case n == 2 && right == "colonnade" && arches: split(y){~1: s(scope.sx-shopDepth,'1,'1)col.LinearArcadeEnd|entablatureH: Entablature} #last end arcade (right)(columns)
case n == 2 && right == "open": split(y){~1: NIL|entablatureH: Entablature} #last end open (right)
case n == 2 && right == "wall": split(y){~1: s(scope.sx-shopDepth,'1,'1) Wall|entablatureH: Entablature} #last end wall (right)
else: NIL


////////////////////
//////SINGLE SEGMENT

SegmentStoa(yDim) -->
case yDim > 0:
	extrude(world.y,50)
	split(y){yDim+extra_height:SegmentBase(yDim)|~1: NIL}
else:t(0,elevation,0)
	extrude(stoaHeight+baseHeight)
	t(0,-extra_steps_down*step_height,0)
	color(base)
	split(y){baseHeight: comp(f){front:StepsType(scope.sy/step_height)
								|back: BackStepsType(scope.sy/step_height)
								|left: LeftStepsType(scope.sy/step_height) 
								|right:RightStepsType(scope.sy/step_height) }
			|~1: SegmentSides}

SegmentBase(yDim) -->
comp(f){top:extrude(stoaHeight) SegmentSides
		|front: color(base)StepsType(scope.sy/step_height)| side:color(base) Wall}

			
SegmentSides -->
color(wall)
split(y){columnHeight:split(z){shopDepth:color(wall)comp(f){front:s('1,scope.sy+entablatureH-.1,'1)dom.LowerFacade(rint(rand(-.5,1.5)),"front")
															|back:Wall
															|left: Wall
															|right:Wall
															|bottom: reverseNormals color(floor) tex.WholeBlock("floor",.5)}
								|~1:comp(f)	{front: FrontSide
											|left: 	LeftSide
											|right: RightSide
											|back: 	BackSide
											|bottom:reverseNormals color(floor) tex.WholeBlock("floor",.5)}	 			
								}
		|~1:  comp(f){front:FrontEntablature(scope.sx)
					|left: Entablature
					|right: Entablature
					|back:FrontEntablature(scope.sx)
					|top: 	Ceiling 
					Roof}
		}
			


FrontSide --> 
	case start && left == "wall" && columns && !propylon: col.NoFirstLastOnBreak(columnSpacing)
	case start && left != "wall" && columns && !propylon: col.FirstFlushLastOnBreak(columnSpacing)
	case last && right != "wall" && columns && !propylon: col.NoFirstLastFlush(columnSpacing)
	case last && right == "wall" && columns && !propylon: col.NoFirstNoLast(columnSpacing)
	case standalone && right != "wall" 	&& left != "wall" && columns && !propylon: 	color(column) col.FirstLastFlush(columnSpacing)	 
	case standalone && right == "wall" 	&& left != "wall" && columns && !propylon: 	color(column) col.FirstFlushNoLast(columnSpacing)
	case standalone && right != "wall"	&& left == "wall" && columns && !propylon: 	color(column) col.NoFirstLastFlush(columnSpacing)	 
	case standalone && right == "wall" 	&& left == "wall" && columns && !propylon: 	color(column) col.NoFirstNoLast(columnSpacing)
	case middle  && columns && !propylon: 	color(column) col.NoFirstLastOnBreak(columnSpacing)
	case arches && start : s(scope.sx-col.archColumnBaseW/2,'1,'1) t(col.archColumnBaseW/2,0,0)col.ArcadeStart
	case arches && standalone: s(scope.sx-col.archColumnBaseW,'1,'1) center(x) col.ArcadeStart
	case arches && !start || arches && !standalone:s(scope.sx-col.archColumnBaseW/2,'1,'1) col.Arcade
	case propylon && columns: PropylonColonnade(scope.sx)
	else: NIL


LeftSide -->
	case start && left == "wall"||
		 standalone && left == "wall": extrude(-wallThickness)Wall
	case start && left == "colonnade" && back != "wall"  && columns ||
		 standalone && left == "colonnade" && back != "wall"  && columns: col.FirstFlushNoLast(columnSpacing)
	case start && left == "colonnade" && back == "wall"  && columns||
		 standalone && left == "colonnade" && back == "wall"  && columns: col.NoFirstNoLast(columnSpacing)
	case arches && left == "colonnade" && back == "colonnade" :  s(scope.sx-col.archColumnBaseW,'1,'1) center(x) col.ArcadeStart
	case arches && left == "colonnade" && back == "wall" :  s(scope.sx-wallThickness,'1,'1) t(wallThickness-col.archColumnBaseW/2,0,0)col.ArcadeStart
	case arches && left == "colonnade" && back == "open" :  s(scope.sx-col.archColumnBaseW/2,'1,'1) col.ArcadeStart
	else: NIL

RightSide -->
	case last && right == "wall"||
		 standalone && right == "wall": extrude(-wallThickness)Wall
	case last && right == "colonnade" && back != "wall" && columns ||
		 standalone && right == "colonnade" && back != "wall"  && columns: col.NoFirstLastFlush(columnSpacing)
	case last && right == "colonnade" && back == "wall"  && columns||
		 standalone && right == "colonnade" && back == "wall" && columns : col.NoFirstNoLast(columnSpacing)
	case arches && right == "colonnade"  && back == "colonnade":  s(scope.sx-col.archColumnBaseW,'1,'1) center(x)col.ArcadeStart
	case arches && right == "colonnade"  && back == "wall":  s(scope.sx-wallThickness,'1,'1)t(col.archColumnBaseW/2,0,0)col.ArcadeStart
	case arches && right == "colonnade"  && back == "open":  s(scope.sx-col.archColumnBaseW/2,'1,'1)t(col.archColumnBaseW/2,0,0)col.ArcadeStart
	else: NIL
	
BackSide -->
	case back == "colonnade" && start && left != "open" && columns && !propylon: col.FirstOnBreakNoLast(columnSpacing)
	case back == "colonnade" && start && left == "open" && columns && !propylon: col.FirstOnBreakLastFlush(columnSpacing)
	case back == "colonnade" && last && right != "open" && columns && !propylon: col.NoFirstNoLast(columnSpacing)
	case back == "colonnade" && last && right == "open" && columns && !propylon: col.FirstFlushNoLast(columnSpacing)
	case back == "colonnade" && standalone && right != "open" 	&& left != "open" && columns && !propylon: 	color(column) col.NoFirstNoLast(columnSpacing)	 
	case back == "colonnade" && standalone && right == "open" 	&& left != "open" && columns && !propylon: 	color(column) col.FirstFlushNoLast(columnSpacing)
	case back == "colonnade" && standalone && right != "open"	&& left == "open" && columns && !propylon: 	color(column) col.NoFirstLastFlush(columnSpacing)	 
	case back == "colonnade" && standalone && right == "open" 	&& left == "open" && columns && !propylon: 	color(column) col.FirstLastFlush(columnSpacing)
	case back == "colonnade" && middle && columns && !propylon : 	color(column) col.FirstOnBreakNoLast(columnSpacing)
	case back == "wall" : extrude(-wallThickness)Wall
	case back == "colonnade" && arches && !last  && !standalone :  s(scope.sx-col.archColumnBaseW/2,'1,'1) col.Arcade
	case back == "colonnade" && arches && last || back == "colonnade" && arches && standalone: s(scope.sx-col.archColumnBaseW/2,'1,'1) t(col.archColumnBaseW/2,0,0) col.ArcadeStart
	case back == "colonnade" && propylon && columns: PropylonColonnade(scope.sx)
	else: NIL
	
PropylonColonnade(X) -->
case tetrastyle:
	GetSpacing((X-((X/3)*centerOpening_propylon))/2)
case hexastyle:
	GetSpacing((X-((X/5)*centerOpening_propylon))/4)
else: GetSpacing(columnSpacing)

GetSpacing(n) -->
col.FirstLastFlushFront(n,centerOpening_propylon)
	
////////////
///////STEPS

BackStepsType(n) -->
case backSteps == "true":StepsType(n)
else: Wall

LeftStepsType(n) -->
case leftSteps == "true":StepsType(n)
else: Wall

RightStepsType(n) -->
case rightSteps == "true":StepsType(n)
else: Wall

StepsType(n) -->
case continuous: Steps(n)
case spaced && columns: Wall split(x){ column_diameter+col.columnOffset: NIL|stairW:Steps(n)|~1: NIL}
case spaced && arches && start || spaced && arches && standalone: Wall split(x){ orderW: NIL|stairW:Steps(n)|~1: NIL}
case spaced && arches && !start && !standalone : Wall split(x){ stairW:Steps(n)|~1: NIL}
else: Wall

Steps -->
split(y){step_height :  extrude((split.total - split.index) * step_depth) s(scope.sx+(split.total - split.index) * step_depth,'1,'1) tex.Block("wall", tile)}*

StepsEnd -->
setPivot(xyz,2)
split(y){~step_height :  extrude((split.total - split.index) * step_depth) tex.Block("wall", tile)}*

Steps(n) -->
alignScopeToAxes()
split(y)	{step_height: Step(n) 
	 	| ~1: Steps(n-1)}

Step(idx) -->
extrude(idx*step_depth)tex.Block("street", streetTexTile)


////////////
///////WALLS

Walls -->
color(wall)
split(y){~1: s('1,'1, wallThickness)
			t(0,0,-wallThickness)
			set(trim.vertical, false)
			i("builtin:cube")
			tex.Block("wall", tile) 
		|entablatureH:Entablature}

ShopWalls -->
color(wall)
s('1,'1,shopDepth)
t(0,0,-shopDepth)
set(trim.vertical,false)
i("builtin:cube")
comp(f){back:ShopFacade |front: Wall | left: Wall| right:  Wall}

ShopFacade -->
case offset:
s(scope.sx-shopDepth*2,scope.sy+entablatureH,'1)
center(x)
dom.LowerFacade(rint(rand(-.5,1.5)),"front") 
else:
s('1,scope.sy+entablatureH,'1)dom.LowerFacade(rint(rand(-.5,1.5)),"front") 

	
Wall --> tex.Block("wall",tile) reverseNormals tex.Block("wall",tile)

//////////////////
///////ENTABLATURE

Entablature -->
case columns: col.Entablature(columnSpacing,column_diameter)
else: col.Entablature(columnSpacing,archColumnDiameter)

FrontEntablature(X) -->
case propylon && columns && tetrastyle:
	col.EntablatureFront(((X-((X/3)*centerOpening_propylon))/2),centerOpening_propylon,column_diameter)
case propylon && columns && hexastyle:
	col.EntablatureFront(((X-((X/5)*centerOpening_propylon))/4),centerOpening_propylon,column_diameter)	
case !propylon && columns: col.Entablature(columnSpacing,column_diameter)
else:
	col.Entablature(columnSpacing,archColumnDiameter)
////////////
////////ROOF

Ceiling -->
case roofType == "flat":
	color(floor)tex.Block("floor",.5)#Flat Roof					
	t(0,0,-column_diameter*col.friezeH) reverseNormals offset(-column_diameter/2,inside)color(roof) tex.Block("roof",4,24)
else:
	t(0,0,-column_diameter*col.friezeH) reverseNormals offset(-column_diameter/2,inside)color(roof) tex.Block("roof",4,24)
	
Roof --> 
case tuscan && propylon:
		s('1.1,'1,'1)
		center(x)
		Roof1
else: Roof1

Roof1 -->
	case roofType == "gable" && !propylon:
		roofGable(roof_angle)
		comp(f){ top : rf.Roof(roofBrickW,roofBrickH)|vertical: tex.Block("wall", tile)}
		comp(e){ ridge: rf.Ridge(0,roofBrickW,roofBrickH) | hip: rf.Ridge(roofBrickW*0.4,roofBrickW,roofBrickH) | valley: rf.Ridge(roofBrickW*0.4,roofBrickW,roofBrickH)}
	case roofType == "gable" && propylon:
		roofGable( roof_angle ,0,-col.geisonProjection-col.triglyphW/2, true,0)
		comp(f){ top : rf.TempleRoof(columnSpacing,roofBrickW,roofBrickH)|vertical: rf.Pediment(columnSpacing)|bottom: Overhang}
		comp(e){ ridge: rf.Ridge(0,roofBrickW,roofBrickH) | hip: rf.Ridge(roofBrickW*0.4,roofBrickW,roofBrickH) | valley: rf.Ridge(roofBrickW*0.4,roofBrickW,roofBrickH)}
	case roofType == "flat":extrude(railingH) comp(f){side:s('1,'1,wallThickness)t(0,0,-wallThickness)i("builtin:cube")tex.Block("wall",tile)}
	else:
		roofShed(roof_angle)
		comp(f){ top : rf.Roof(roofBrickW,roofBrickH)|vertical: tex.Block("wall", tile)}
		comp(e){ ridge: rf.Ridge(0,roofBrickW,roofBrickH) | hip: rf.Ridge(roofBrickW*0.4,roofBrickW,roofBrickH) | valley: rf.Ridge(roofBrickW*0.4,roofBrickW,roofBrickH)}

Overhang -->
	case tuscan:
		split(y){rf.pedimentWidth-col.geisonProjection: NIL
				|~1: 	s('1,'1.02,.1)
						center(y)
						tex.Block("wall",tile)
				|rf.pedimentWidth-col.geisonProjection: NIL}
		
	else: NIL		


style Comitium_2
attr YEAR = -160.0
attr stepType = "continuous"
attr columnSpacing = 3.0
attr column_diameter = 0.7


style Comitium_1
attr YEAR = 0.0
attr stepType = "continuous"
attr columnSpacing = 3.0
attr column_diameter = 0.7
